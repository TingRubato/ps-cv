---
layout: post
title: a post with images
date: 2015-05-15 21:01:00
description: this is what included images could look like
tags: formatting images
categories: sample-posts
thumbnail: assets/img/9.jpg
---

<div class="container mt-4">
  <h1>About Me</h1>

  <!-- Instead of the old profile image snippet,
       we have a canvas + script-based Observable-like approach -->
  <canvas id="quadCanvas" width='800' height='600' style="max-width: 100%;">
    <!-- fallback text if JS is disabled -->
    Sorry, your browser doesn’t support the HTML5 <code>canvas</code> element.
  </canvas>
</div>

<script type="module">
  // 1) Import from CDNs
  import {easeCubicInOut} from "https://cdn.skypack.dev/d3-ease@3";
  import * as d3interpolate from "https://cdn.jsdelivr.net/npm/d3-interpolate@3.0.1/+esm";
  import tinyqueue from 'https://cdn.jsdelivr.net/npm/tinyqueue@3.0.0/+esm';
  // 2) Load your image from assets
  //    Typically, you’d do something like create an <img>, wait for it to load, then draw:
  const imageURL = "{{ '/assets/img/12.jpeg' | relative_url }}"; // Adjust as needed

  // 3) Helper: load image as a Promise
  async function loadImage(src) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.crossOrigin = 'anonymous';  // if needed
      img.onload = () => resolve(img);
      img.onerror = (e) => reject(e);
      img.src = src;
    });
  }

  // Weighted average, same as your Observable code
  function weightedAverage(histogram) {
    let total = 0;
    let value = 0;
    for (let i = 0; i < 256; ++i) {
      total += histogram[i];
      value += histogram[i] * i;
    }
    value /= total;
    let error = 0;
    for (let i = 0; i < 256; ++i) {
      error += (value - i) ** 2 * histogram[i];
    }
    return [value, Math.sqrt(error / total)];
  }

  // colorFromHistogram
  function colorFromHistogram(histogram) {
    const [r, re] = weightedAverage(histogram.subarray(0, 256));
    const [g, ge] = weightedAverage(histogram.subarray(256, 512));
    const [b, be] = weightedAverage(histogram.subarray(512, 768));
    return [
      Math.round(r),
      Math.round(g),
      Math.round(b),
      re * 0.2989 + ge * 0.5870 + be * 0.1140
    ];
  }

  // We'll store a global context or use a closure var
  let imageContext;

  function computeHistogram(x, y, w, h) {
    const {data} = imageContext.getImageData(x, y, w, h);
    const histogram = new Uint32Array(1024);
    for (let i = 0, n = data.length; i < n; i += 4) {
      ++histogram[0 * 256 + data[i + 0]];
      ++histogram[1 * 256 + data[i + 1]];
      ++histogram[2 * 256 + data[i + 2]];
      ++histogram[3 * 256 + data[i + 3]];
    }
    return histogram;
  }

  class Quad {
    constructor(x, y, w, h) {
      const [r, g, b, error] = colorFromHistogram(computeHistogram(x, y, w, h));
      this.x = x; 
      this.y = y; 
      this.w = w; 
      this.h = h;
      // Convert R,G,B → #rrggbb
      this.color = "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
      this.score = error * Math.pow(w * h, area_power);
    }
    split() {
      const dx = this.w / 2, x1 = this.x, x2 = this.x + dx;
      const dy = this.h / 2, y1 = this.y, y2 = this.y + dy;
      return [
        new Quad(x1, y1, dx, dy),
        new Quad(x2, y1, dx, dy),
        new Quad(x1, y2, dx, dy),
        new Quad(x2, y2, dx, dy),
      ];
    }
  }

  const area_power = 0.25;
  const canvasSize = 1024;

  // Our main “draw quads” generator
  // (We’ll just do a standard async function with intervals to mimic yield.)
  async function drawQuads(context) {
    const quads = new tinyqueue([ new Quad(0, 0, canvasSize, canvasSize) ], (a, b) => b.score - a.score);

    while (true) {
      const q = quads.pop();
      if (!q || q.score < 50) break;

      // Sub-split
      const qs = q.split();
      // We do an interpolation from q->q->q->q to q->q->q->q ??? (like in your original code)
      // Actually, we want from [q, q, q, q] to qs to animate the “split”
      const qsi = d3interpolate.interpolate([q, q, q, q], qs);

      qs.forEach((quad) => quads.push(quad));

      const steps = Math.max(1, Math.floor(q.w / 10));
      for (let j = 1; j <= steps; j++) {
        const t = easeCubicInOut(j / steps);

        // Clear the region
        context.clearRect(q.x, q.y, q.w, q.h);

        // Draw each piece
        for (const s of qsi(t)) {
          context.fillStyle = s.color;
          context.beginPath();
          context.moveTo(s.x + s.w, s.y + s.h / 2);
          context.arc(s.x + s.w / 2, s.y + s.h / 2, s.w / 2, 0, 2 * Math.PI);
          context.fill();
        }

        // Small delay so we can see the animation
        await new Promise(r => setTimeout(r, 10));
      }
    }
  }

  // 4) Actually run everything
  (async function init() {
    // Load the base image
    const baseImage = await loadImage(imageURL);

    // “imageContext” for our histogram computations
    const hiddenCanvas = document.createElement('canvas');
    hiddenCanvas.width = canvasSize;
    hiddenCanvas.height = canvasSize;
    imageContext = hiddenCanvas.getContext('2d');
    // Draw the base image so we can read its pixels
    imageContext.drawImage(baseImage, 0, 0, canvasSize, canvasSize);

    // The main visible canvas
    const mainCanvas = document.getElementById("quadCanvas");
    const mainCtx = mainCanvas.getContext("2d");

    // Initially just draw the original image (optional):
    mainCtx.drawImage(baseImage, 0, 0, canvasSize, canvasSize);

    // Kick off the quad-splitting animation
    await drawQuads(mainCtx);

  })();
</script>
